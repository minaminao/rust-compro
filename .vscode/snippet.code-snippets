{"tmp.rs": {"prefix": "tmp", "scope": "cpp", "body": "#[allow(unused_imports)]\nuse std::cmp::{max, min};\n#[allow(unused_imports)]\nuse std::collections::{HashMap, HashSet};\n#[allow(unused_imports)]\nuse std::io::*;\n#[allow(unused_imports)]\nuse std::str::*;\n\nmacro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        let mut next = || { iter.next().unwrap() };\n        input_inner!{next, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let stdin = std::io::stdin();\n        let mut bytes = std::io::Read::bytes(std::io::BufReader::new(stdin.lock()));\n        let mut next = move || -> String{\n            bytes\n                .by_ref()\n                .map(|r|r.unwrap() as char)\n                .skip_while(|c|c.is_whitespace())\n                .take_while(|c|!c.is_whitespace())\n                .collect()\n        };\n        input_inner!{next, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($next:expr) => {};\n    ($next:expr, ) => {};\n\n    ($next:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($next, $t);\n        input_inner!{$next $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($next:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($next, $t)),* )\n    };\n\n    ($next:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    };\n\n    ($next:expr, chars) => {\n        read_value!($next, String).chars().collect::<Vec<char>>()\n    };\n\n    ($next:expr, usize1) => {\n        read_value!($next, usize) - 1\n    };\n\n    ($next:expr, $t:ty) => {\n        $next().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\n#[allow(dead_code)]\nfn read<T: FromStr>() -> T {\n    let cin = stdin();\n    let cin = cin.lock();\n    let s: String = cin\n        .bytes() // Bytes\n        .map(|c| c.expect(\"failed reading char\") as char)\n        .skip_while(|c| c.is_whitespace()) // c \u304c whitespace \u3067\u3042\u308b\u9650\u308a skip\n        .take_while(|c| !c.is_whitespace()) // c \u304c whitespace \u3067\u306a\u3044\u9650\u308a\u8981\u7d20\u3092\u8fd4\u3059\n        .collect();\n    s.parse().ok().expect(\"failed parsing\")\n}\n\nfn main() {}"}, "tmp2.rs": {"prefix": "tmp2", "scope": "cpp", "body": "#[allow(unused_imports)]\nuse std::cmp::{max, min};\n#[allow(unused_imports)]\nuse std::collections::{HashMap, HashSet};\n#[allow(unused_imports)]\nuse std::io::*;\n#[allow(unused_imports)]\nuse std::str::*;\n\n#[allow(dead_code)]\nfn read<T: FromStr>() -> T {\n    let cin = stdin();\n    let cin = cin.lock();\n    let s: String = cin\n        .bytes() // Bytes\n        .map(|c| c.expect(\"failed reading char\") as char)\n        .skip_while(|c| c.is_whitespace()) // c \u304c whitespace \u3067\u3042\u308b\u9650\u308a skip\n        .take_while(|c| !c.is_whitespace()) // c \u304c whitespace \u3067\u306a\u3044\u9650\u308a\u8981\u7d20\u3092\u8fd4\u3059\n        .collect();\n    s.parse().ok().expect(\"failed parsing\")\n}\n\nfn main() {}"}, "tips.rs": {"prefix": "tips", "scope": "cpp", "body": "#[allow(unused_imports)]\nuse std::cmp::{max, min};\n#[allow(unused_imports)]\nuse std::collections::{HashMap, HashSet};\n#[allow(unused_imports)]\nuse std::io::*;\n#[allow(unused_imports)]\nuse std::str::*;\n\nfn main() {\n    let a = 0;\n    let n = 0;\n\n    // HashSet\n    let mut st = HashSet::new();\n    st.insert(1);\n    st.contains(&a);\n\n    let n = format!(\"{:b}\", n);\n\n    // String\n    let s: String;\n    s.chars().collect::<Vec<char>>();\n    s.chars().filter(|c| *c == '1').count();\n    s.chars().filter(|&c| c == 'o').count();\n    s.replace(\"2017\", \"2018\");\n    v.iter().collect::<String>()\n\n    // \u5165\u529b\n    input! {s:String}\n    let s = s.chars().collect::<Vec<char>>();\n\n    let mut ans = None;\n    for c in b'a'..b'z' + 1 {\n        let c = char::from(c);\n        ans = Some(c.to_string());\n    }\n    println!(\"{}\", ans.unwrap_or(\"None\".to_string()));\n\n    let ans: String = t.into_iter().collect();\n    println!(\n        \"{}\",\n        if a == b.chars().rev().collect::<String>() {\n            \"YES\"\n        } else {\n            \"NO\"\n        }\n    )\n}\n"}}